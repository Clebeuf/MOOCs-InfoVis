<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">

	<!-- JQuery script -->
	<script src="http://code.jquery.com/jquery-2.1.0.min.js"></script>

	<!-- Style sheet for D3 -->
	<link rel="stylesheet" type="text/css" href="css/style.css">

	<!-- BOOTSTRAP SCRIPTS-->
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css">
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap-theme.min.css">
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>

	<link rel="stylesheet" type="text/css" href="https://syntagmatic.github.io/parallel-coordinates/d3.parcoords.css">
	<title>MOOCs Success InfoVis</title>

</head>

<body onload="loadCoordinates()">

	<!-- SCRIPTS -->
	<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
	<script src="http://mostapharoudsari.github.io/Honeybee/pc_source_files/d3/d3.parcoords.js"></script>
	<script src="http://d3js.org/topojson.v1.min.js"></script>
	<script src="js/datamaps.world.min.js"></script>

	<div class="container">

		<div class="row">
			<div class="col-md-12">
				<h1>Visualizing MOOCs Success</h1>
			</div>
		</div>
		<div class="row">
			<div class="col-md-2">
				<div class="form-group">
					<h4>Filters:</h4>
					<form id="frm1" onchange="refreshCoordinates()">
						Type of Data:
						<select id="explored" >
						  <option value="1">Explored</option>
						  <option value="0">Not Explored</option>
						</select>

						Colour Data by:
						<select id="dataColouring" >
						  <option value="certified">Certified</option>
						  <option value="gend">Gender</option>
						  <option value="LoE_DI">Education Level</option>
						</select>

						<div class="checkbox">
						  	Years:<br>
						      <label class="checkbox-inline">
						      	<input type="checkbox" id="2012" checked> 2012
						      </label>
						      <label class="checkbox-inline">
						      	<input type="checkbox" id="2013" checked> 2013
						      </label>
						</div>
					</form>
					<form id="courseForm" onchange="refreshCoordinates()">
						<div class="checkbox">
						  	Harvard Courses:
								<br><label><input type="checkbox" id="PH207x" checked> HealthStat</label>
								<br><label><input type="checkbox" id="PH278x" checked> HealthEnv</label>
								<br><label><input type="checkbox" id="CB22x" checked> HeroesX*</label>
								<br><label><input type="checkbox" id="CS50x" checked> Intro to CS*</label>
								<br><label><input type="checkbox" id="ER22x" checked> JusticeX*</label>
							<br>MIT Courses:
								<br><label><input type="checkbox" id="14.73x" checked> Poverty</label>
								<br><label><input type="checkbox" id="2.01x" checked> Structures</label>
								<br><label><input type="checkbox" id="3.091x" checked> SS Chem</label>
								<br><label><input type="checkbox" id="6.002x" checked> Circuits</label>
								<br><label><input type="checkbox" id="6.00x" checked> Intro to CS</label>
								<br><label><input type="checkbox" id="7.00x" checked> Biology</label>
								<br><label><input type="checkbox" id="8.02x" checked> Electricity</label>
								<br><label><input type="checkbox" id="8.MReV" checked> MechRev</label>
						</div>
						<a onclick="javascript:checkAll(true);" href="javascript:void();">check all</a>
						<a onclick="javascript:checkAll(false);" href="javascript:void();">uncheck all</a>
					</form>
					<br><br>

					<form id="frm2">
						<select id="dimensionMapped">
							<option value="grade">Grade</option>
							<option value="certified">Certified</option>
						</select>
					</form>
					<br />
					<button onclick="getBrushedData()">See on Map</button>
				</div>
			</div>
			<div class="col-md-10">

				<div id="example" class="parcoords" style="width:100%;height:400px"></div>

				<script>


				function checkAll(checktoggle){
				  var checkboxes = document.getElementsByTagName('input');

				  for (var i=0; i<checkboxes.length; i++)  {
				    if (checkboxes[i].type == 'checkbox')   {
				    	if (["PH207x","PH278x","CB22x","CS50x","ER22x","14.73x","2.01x","3.091x","6.002x","6.00x","7.00x","8.02x","8.MReV"].indexOf(checkboxes[i].id) > -1){
				    		 checkboxes[i].checked = checktoggle;
				    	}
				    }
				  }
				  refreshCoordinates();
				}

					// CREATE THE PARALLEL COORDINATES
					var pc = d3.parcoords({
						dimensionTitles: {
							nplay_video: "video plays",
							final_cc_cname_DI: "country",
							LoE_DI: "education level",
							nevents: "# of events",
							nforum_posts: "# of forums posts",
							nchapters: "# of chapters",
							ndays_act: "# days active"
						}
					})('#example')

					// load the json data from a file
					var json = (function() {
				        var json = null;
				        $.ajax({
				            'async': false,
				            'global': false,
				            'url': "/data/output.json",
				            'dataType': "json",
				            'success': function (data) {
				                json = data;
				            }
				        });
				        return json;
				    })();

					function filterDataset(){
							var e = document.getElementById("explored");
							var strUser = e.options[e.selectedIndex].value;
							var exploredValue = parseInt(strUser);

							var dataFillered = json.filter(function (n) {
					    		if(exploredValue === 1){
					    			if(document.getElementById("2012").checked == true && document.getElementById("2013").checked == true){
					    				return (n.explored===1 && (n.year==2012 || n.year == 2013));
					    			}else if(document.getElementById("2012").checked == true){
					    				return (n.explored===1 && n.year==2012);
					    			}else if(document.getElementById("2013").checked){
					    				return (n.explored===1 && n.year==2013)
					    			};
					    		} else {
					    			if(document.getElementById("2012").checked == true){
					    				return (n.explored===0 && n.year==2012);
					    			};
					    			if(document.getElementById("2013").checked){
					    				return (n.explored===0 && n.year==2013)
					    			};
					    		}

							});

						return dataFillered
					}

					function filterByCourse(data){
						var dataFillered = data.filter(function (m) {
							if (document.getElementById("CB22x").checked && m.course_id=="CB22x"){
								return m.course_id=="CB22x";
							}else if (document.getElementById("CS50x").checked && m.course_id=="CS50x"){
								return m.course_id=="CS50x";
							}else if (document.getElementById("ER22x").checked && m.course_id=="ER22x"){
								return m.course_id=="ER22x";
							}else if (document.getElementById("PH207x").checked && m.course_id=="PH207x"){
								return m.course_id=="PH207x";
							}else if (document.getElementById("PH278x").checked && m.course_id=="PH278x"){
								return m.course_id=="PH278x";
							}else if (document.getElementById("14.73x").checked && m.course_id=="14.73x"){
								return m.course_id=="14.73x";
							}else if (document.getElementById("2.01x").checked && m.course_id=="2.01x"){
								return m.course_id=="2.01x";
							}else if (document.getElementById("3.091x").checked && m.course_id=="3.091x"){
								return m.course_id=="3.091x";
							}else if (document.getElementById("6.002x").checked && m.course_id=="6.002x"){
								return m.course_id=="6.002x";
							}else if (document.getElementById("6.00x").checked && m.course_id=="6.00x"){
								return m.course_id=="6.00x";
							}else if (document.getElementById("7.00x").checked && m.course_id=="7.00x"){
								return m.course_id=="7.00x";
							}else if (document.getElementById("8.02x").checked && m.course_id=="8.02x"){
								return m.course_id=="8.02x";
							}else if (document.getElementById("8.MReV").checked && m.course_id=="8.MReV"){
								return m.course_id=="8.MReV";
							}
						});

						return dataFillered
					}


					// load the coordinates from the file and set the options
					function loadCoordinates(){

						// create coloured tuples
						var colorgen = d3.scale.ordinal().range(["brown","steelblue"]);
						var color = function(d) { return colorgen(d.certified); };

						// generate the parallel-coordinates
						d3.json("data/explored.json", function(data) {
							pc.data(data)
							.ticks(4)
							.mode("queue")
							.color(color)
							.composite("darker")
							.alpha(0.15)
							.render()
							.dimensions(['LoE_DI','ndays_act', 'nchapters', 'nplay_video', 'nevents', 'nforum_posts', 'grade', 'certified'])
							.createAxes()
							.brushMode("1D-axes")
							.interactive()
							.reorderable();
						});
					}


					// refresh the coordinates for the new filters selected
					function refreshCoordinates(){

						// Filter the preloaded json
						dataF = filterDataset();
						dataC = filterByCourse(dataF);


						var e = document.getElementById("dataColouring");
						var dimention = e.options[e.selectedIndex].value;
						if (dimention == 'LoE_DI'){
							var colorgen = d3.scale.ordinal().range(["#a6cee3","#1f78b4","#b2df8a","#33a02c","#fb9a99","#e31a1c"]);
							var color = function(d) { return colorgen(d.LoE_DI); };
						}else if(dimention == 'certified'){
							var colorgen = d3.scale.ordinal().range(["brown","steelblue"]);
							var color = function(d) { return colorgen(d.certified); };
						}else{
							var colorgen = d3.scale.ordinal().range(["steelblue","brown"]);
							var color = function(d) { return colorgen(d.gender); };
						}

						// refresh the coordinates
						pc.data(dataC)
						.color(color)
						.render()
						.updateAxes();

					}

					pc.on("highlight", function(data) {
						getBrushedData();
					});

					var mapJson = {};

					function getBrushedData() {
						mapJson = {};
						mapJson = new Object;
						var data;
						if (pc.brushed()) {
							data = pc.brushed();
						} else {
							data = json;
						}
						for (i = 0; i < data.length; i++) {
							addToJsonMapData(data[i]);
						}
						changeJsonMap();
					}

					function addToJsonMapData(student) {
						var countryName = countryCodes[student.final_cc_cname_DI];

						if (!countryName) {
							if (student.final_cc_cname_DI != 'unknown') {
								console.log(student.final_cc_cname_DI);
							}
							return;
						}
						if (countryName in mapJson) {
							jsonObj = mapJson[countryName];
							if (student.certified) {
								jsonObj.certified = jsonObj.certified+1;
							} else {
								jsonObj.uncertified = jsonObj.uncertified+1;
							}
							mapJson[countryName] = jsonObj;
						} else {
							var newObj = {};
							if (student.certified) {
								newObj.certified = 1;
								newObj.uncertified = 0;
							} else {
								newObj.certified = 0;
								newObj.uncertified = 1;
							}
							mapJson[countryName] = newObj;
						}
					}

					var mapData = {};
					function changeJsonMap() {
						for (var key in mapData) {
							if (!(key in mapJson)) {
								var newObj = {};
								newObj.certifiedPercent = 0;
								newObj.fillKey = 'defaultFill';
								mapData[key] = newObj;
							}
						}
						for (var key in mapJson) {
							var data = mapJson[key];

							var newObj = {};
							var percentage = data.certified / (data.certified + data.uncertified);
							newObj.certifiedPercent = percentage;
							var fill;
							if (percentage < 0.20) {
								fill = 'verylow';
							} else if (percentage >= 0.20 && percentage < 0.40) {
								fill = 'low';
							} else if (percentage >= 0.40 && percentage < 0.60) {
								fill = 'medium';
							} else if (percentage >= 0.60 && percentage < 0.80) {
								fill = 'high';
							} else {
								fill = 'veryhigh';
							}
							newObj.fillKey = fill;
							mapData[key] = newObj;
						}
						updateChoropleth(mapData);
					}

					var countryCodes = {};
					//Americas
					countryCodes['United States'] = 'USA';
					countryCodes['Canada'] = 'CAN';
					countryCodes['Mexico'] = 'MEX';
					countryCodes['Colombia'] = 'COL';
					countryCodes['Venezuela'] = 'VEN';
					countryCodes['Ecuador'] = 'ECU';
					countryCodes['Peru'] = 'PER';
					countryCodes['Brazil'] = 'BRA';
					countryCodes['Bolivia'] = 'BOL';
					countryCodes['Argentina'] = 'ARG';
					countryCodes['Chile'] = 'CHL';
					//Europe
					countryCodes['United Kingdom'] = 'GBR';
					countryCodes['Ireland'] = 'IRL';
					countryCodes['France'] = 'FRA';
					countryCodes['Spain'] = 'ESP';
					countryCodes['Portugal'] = 'PRT';
					countryCodes['Italy'] = 'ITA';
					countryCodes['Poland'] = 'POL';
					countryCodes['Greece'] = 'GRC';
					countryCodes['Germany'] = 'DEU';
					countryCodes['Norway'] = 'NOR';
					countryCodes['Sweden'] = 'SWE';
					countryCodes['Finland'] = 'FIN';
					countryCodes['Ukraine'] = 'UKR';
					countryCodes['Russian Federation'] = 'RUS';
					//Africa
					countryCodes['Egypt'] = 'EGY';
					countryCodes['Morocco'] = 'MAR';
					countryCodes['Nigeria'] = 'NGA';
					//Middle East
					countryCodes['Turkey'] = 'TUR';
					countryCodes['Iraq'] = 'IRQ';
					countryCodes['Iran'] = 'IRN';
					countryCodes['Saudi Arabia'] = 'SAU';
					countryCodes['Afghanistan'] = 'AFG';
					//Asia
					countryCodes['Pakistan'] = 'PAK';
					countryCodes['India'] = 'IND';
					countryCodes['Bangladesh'] = 'BGD';
					countryCodes['China'] = 'CHN';
					countryCodes['Thailand'] = 'THA';
					countryCodes['Cambodia'] = 'KHM';
					countryCodes['Vietnam'] = 'VNM';
					//korea?
					countryCodes['Japan'] = 'JPN';
					countryCodes['Malaysia'] = 'MYS';
					countryCodes['Philippines'] = 'PHL';
					countryCodes['Indonesia'] = 'IDN';
					countryCodes['Australia'] = 'AUS';
					countryCodes['New Zealand'] = 'NZL';

				</script>

				<!-- function to call popovers -->
				<script type="text/javascript">
					$(document).ready(function(){
					    $('[data-toggle="popover"]').popover();
					});
				</script>

			</div>
		</div>
		<div class="row">
			<div class="col-md-12">
				<h3>THE TEMPORAL CONTROL GOES HERE</h3>
				<div id="slider"></div>
			</div>
		</div>
		<div class="row">
			<div class="col-md-12">
				<div id="basic" style="position: relative; width: 100%; height: 500px;"></div>

			     <script>
			       //basic map config with custom fills, mercator projection
					var basic = new Datamap({
						element: document.getElementById("basic"),
						fills: {
							defaultFill: "#ABDDA4",
							verylow: "#87CEFA",
							low: "#6495ED",
							medium: "#4169E1",
							high: "#0000FF",
							veryhigh: "#0000CD"
						},
						data: {

						},
						geographyConfig: {
							popupTemplate: function(geo, data) {
								if (data == null) {
									return ['<div class="hoverinfo"><strong>',
									 	geo.properties.name,
										'</strong></div>'].join('');
								}
								else {
									//if looking at certified
									var percentage = data.certifiedPercent*100;
									percentage = percentage.toPrecision(3);
									return ['<div class="hoverinfo"><strong>',
				                        'Students Certified in ' + geo.properties.name,
				                        ': ' + percentage + '%',
				                        '</strong></div>'].join('');
								}
							}
						}
					});

					function updateChoropleth(json) {
						basic.updateChoropleth(json);
						basic.legend();
					}

			     </script>
			</div>
			//all shamelessly stolen from http://bl.ocks.org/syntagmatic/7e7ee384f7cf515f6602
			<script>
				d3.select("#example")
				.on("mousemove", function() {
					var mousePosition = d3.mouse(this);
					highlightLineOnClick(mousePosition, true); //true will also add tooltip
				})
				.on("mouseout", function(){
					// cleanTooltip();
					pc.unhighlight();
				});

				function highlightLineOnClick(mouseClick, drawTooltip){
					var clicked = [];
					var clickedCenPts = [];

					clickedData = getClickedLines(mouseClick);

					if (clickedData && clickedData[0].length!=0){

						clicked = clickedData[0];
						clickedCenPts = clickedData[1];

						// highlight clicked line
						pc.highlight(clicked);

						if (drawTooltip){
							// clean if anything is there
							// cleanTooltip();
							// add tooltip
							// addTooltip(clicked, clickedCenPts);
						}

					}
				}

				function getClickedLines(mouseClick){
					var clicked = [];
					var clickedCenPts = [];

					// find which data is activated right now
					var activeData = getActiveData();

					// find centriod points
					var graphCentPts = getCentroids(activeData);

					if (graphCentPts.length==0) return false;

					// find between which axes the point is
					var axeNum = findAxes(mouseClick, graphCentPts[0]);
					if (!axeNum) return false;

					graphCentPts.forEach(function(d, i){
					if (clicked.length > 1) return;
						if (isOnLine(d[axeNum-1], d[axeNum], mouseClick, 2)){
							clicked.push(activeData[i]);
							clickedCenPts.push(graphCentPts[i]); // for tooltip
						}
					});

					return [clicked, clickedCenPts]
				}

				function isOnLine(startPt, endPt, testPt, tol){
					// check if test point is close enough to a line
					// between startPt and endPt. close enough means smaller than tolerance
					var x0 = testPt[0];
					var	y0 = testPt[1];
					var x1 = startPt[0];
					var	y1 = startPt[1];
					var x2 = endPt[0];
					var	y2 = endPt[1];
					var Dx = x2 - x1;
					var Dy = y2 - y1;
					var delta = Math.abs(Dy*x0 - Dx*y0 - x1*y2+x2*y1)/Math.sqrt(Math.pow(Dx, 2) + Math.pow(Dy, 2));
					//console.log(delta);
					if (delta <= tol) return true;
					return false;
				}

				function findAxes(testPt, cenPts){
					// finds between which two axis the mouse is
					var x = testPt[0];
					var y = testPt[1];

					// make sure it is inside the range of x
					if (cenPts[0][0] > x) return false;
					if (cenPts[cenPts.length-1][0] < x) return false;

					// find between which segment the point is
					for (var i=0; i<cenPts.length; i++){
						if (cenPts[i][0] > x) return i;
					}
				}

				function getCentroids(data){
					// this function returns centroid points for data. I had to change the source
					// for parallelcoordinates and make compute_centroids public.
					// I assume this should be already somewhere in graph and I don't need to recalculate it
					// but I couldn't find it so I just wrote this for now
					var margins = pc.margin();
					var graphCentPts = [];

					data.forEach(function(d){

						var initCenPts = pc.compute_centroids(d).filter(function(d, i){return i%2==0;});

						// move points based on margins
						var cenPts = initCenPts.map(function(d){
							return [d[0] + margins["left"], d[1]+ margins["top"]];
						});

						graphCentPts.push(cenPts);
					});

					return graphCentPts;
				}

				function getActiveData(){
					// I'm pretty sure this data is already somewhere in graph
					if (pc.brushed()!=false) return pc.brushed();
					return pc.data();
				}
			</script>
		 </div>
	 </div>
</body>
</html>
